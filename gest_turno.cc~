#include <iostream>
#include "struttura_dati.h"
#include "gest_turno.h"
#include <gtk/gtk.h>
#include <stdlib.h>
#include <fstream>
#include <cstring>

using namespace std;

/** Setta il campo sensitive della mano del giocatore, in base al giocatore.
 */ 

// idea, fai un case con 2 casi senza break che entrano negli altri.
void setta_mano(){
	if(gioca == giocatoreA){
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta1")),true);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta2")),true);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta3")),true);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta4")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta5")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta6")),false);
		}
	else{
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta1")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta2")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta3")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta4")),true);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta5")),true);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta6")),true);
		}
}


/** Funzione che ristabilisce il gioco:
  * libera il campo e carica le carte nella mano.
  */
void refresh_mano(int i){
	
	
	if(turno == primo){
		switch(i){
			case 0: gtk_image_set_from_file(GTK_IMAGE
				(gtk_builder_get_object(builder, "0")),partita.player1.mano[i].nome);
				gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder, "0")), true);
				break;
			case 1: gtk_image_set_from_file(GTK_IMAGE
				(gtk_builder_get_object(builder, "1")),partita.player1.mano[i].nome);
				gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder, "1")), true);
				break;
			case 2: gtk_image_set_from_file(GTK_IMAGE
				(gtk_builder_get_object(builder, "2")),partita.player1.mano[i].nome);
				gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder, "2")), true);
				break;
			default: cout<<"ERRORE, IMPOSSIBILE!!"<<endl;
			}
		
	
		switch(i){
			case 0: gtk_image_set_from_file(GTK_IMAGE
				(gtk_builder_get_object(builder, "3")),partita.player2.mano[i].nome);
				gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder, "3")), true);
				break;
			case 1: gtk_image_set_from_file(GTK_IMAGE
				(gtk_builder_get_object(builder, "4")),partita.player2.mano[i].nome);
				gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder, "4")), true);
				break;
			case 2: gtk_image_set_from_file(GTK_IMAGE
				(gtk_builder_get_object(builder, "5")),partita.player2.mano[i].nome);
				gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder, "5")), true);
				break;
			default: cout<<"ERRORE, IMPOSSIBILE!!"<<endl;
			}
		}
	partita.idx++;
}


/** Funzione che genera la mano di gioco, caricando le carte da mazzo,
 *  alle rispettive mani.
 *  Funge anche da aggiornamento della mano durante il gioco.
 */
void carica_mano(){

	for(int i=0; i<3; i++){
		if(partita.player1.mano[i].selez == true){
			partita.player1.mano[i].val=partita.mazzo[partita.idx].val;
			strcpy(partita.player1.mano[i].nome, partita.mazzo[partita.idx].nome);
			partita.player1.mano[i].selez=partita.mazzo[partita.idx].selez;

			refresh_mano(i);
			
			partita.player1.mano[i].selez = false;
			}
		}

	for(int i=0; i<3; i++){
		if(partita.player2.mano[i].selez == true){
			partita.player2.mano[i].val=partita.mazzo[partita.idx].val;
			strcpy(partita.player2.mano[i].nome, partita.mazzo[partita.idx].nome);
			partita.player2.mano[i].selez=partita.mazzo[partita.idx].selez;
			

			refresh_mano(i);

			partita.player2.mano[i].selez = false;
			}
		}

	//IMPORTANTE
	// Faccio idx++ perchè in questo momento punta alla carta del mazzo che però è la mia
	// briscola, quindi non posso pescarla, e la salto perchè deve rimanere fissa
	partita.idx++;
}


/** Funzione che restituisce il valore intero dell'indice della mano, corrispondente
  * alla carta premuta. Ritorna un numero compreso tra 0 e 2.
  */
int ricerca_idx_carta(bool set_mano){
	//cerca in player1.mano
	int idx;
	if(set_mano == true){
		for(int i=0; i<NUM_MANO; i++){
			if(partita.player1.mano[i].selez == true)
				idx = i;
			}
		}
	else{
		for(int i=0; i<NUM_MANO; i++){
			if(partita.player2.mano[i].selez == true)
				idx = i;
			}
		}
	return idx;
	}

/** Funzione che somma al punteggio precedente del giocatore vincente,
 *  i pesi delle nuove carte.
 */
void calcola_punteggio(int vinc, int v1, int v2){
	if(vinc == giocatoreA)
		partita.player1.punteggio=partita.player1.punteggio+PESI[v1%10]+PESI[v2%10];
	if(vinc == giocatoreB)
		partita.player2.punteggio=partita.player2.punteggio+PESI[v1%10]+PESI[v2%10];	
}

/** Funzione che gestisce chi ha vinto, quindi recupera le due carte premute
 *  (saranno quelle con stato selez a true), le confronta tra loro, 
 *  dando la precedenza a quella giocata per prima, poi confrontandole con la 
 *  briscola, e settando il giocatore che ha vinto la mano.
 */
void gestore_vittoria(){
	/* Ricordandoci che in passa turno, abbiamo già cambiato il giocatore, 
	 * quindi alla fine mi ritrovo che adesso gioca è già settato al giocatore
 	 * che ha giocato per primo.
	 */
	
	/* Alcune variabili int per dirmi il seme, che mi servirà per sapere qual'è quello dominante.
	 * IL val, per sapere il numero(a parità di seme, deve dirmi qual'è quello con il numero più alto).
	 */
	int val1, val2;
	//indici della carta che avrà campo selez a true;
	int idx_mia_mano;
	int idx_avv_mano;
	
	// true per mano giocatore1, e false per mano del giocatore2
	idx_mia_mano = ricerca_idx_carta(true);
	idx_avv_mano = ricerca_idx_carta(false);
	cout<<"idx_mio= "<<idx_mia_mano<<"\nidx_avv= "<<idx_avv_mano<<endl;

	if(gioca == giocatoreA){
		val1=partita.player1.mano[idx_mia_mano].val;
		val2=partita.player2.mano[idx_avv_mano].val;
		}
	else{
		val1=partita.player2.mano[idx_avv_mano].val;
		val2=partita.player1.mano[idx_mia_mano].val;
		}

	
	cout<<"val1 = "<<val1<<"\nval2 = "<<val2<<endl;
	//adesso di default setto le priorità first a quella giocata per prima, 
	//e second a quella seconda.
	
	prior_carta_t priorc1 = first;
	prior_carta_t priorc2 = second;

	// la briscola è l'intero della divisione del mazzo[6].
	int briscola = (partita.mazzo[6].val/10)+1;
	
	// valuto ora se una delle 2 è briscola, o entrambe
	if((val1/10)+1 == briscola){
		priorc1 = brisc;
		cout<<"val1 briscola\n";
		}
	if((val2/10)+1 == briscola){
		priorc2 = brisc;
		cout<<"val2 briscola\n";
		}
	
	//valuto se hanno lo stesso seme
	if((val1/10)+1 == (val2/10)+1){
		priorc2 = priorc1;
		cout<<"stesso seme\n";
		}
	
	// adesso devo gestire il fatto della vittoria
	int vinc;
	if(priorc1 == priorc2){
		//deve confrontare la precedenza in bade al vettore PREC
		int valor1=PREC[val1%10];
		int valor2=PREC[val2%10];
		
		if(gioca == giocatoreA && valor1 < valor2)
			vinc=0;
		else if(gioca == giocatoreB && valor1 < valor2)
			vinc=1;
		else if(gioca == giocatoreA && valor1 > valor2){
			gioca=giocatoreB;
			vinc=1;
			}
		else if(gioca == giocatoreB && valor1 > valor2){
			gioca=giocatoreA;
			vinc=0;
			}
		
		/*val1%10 > val2%10 ? gioca=giocatoreA : gioca=giocatoreB;*/
		cout<<"sempre qui\n";
		
		}	
	else if(priorc1 < priorc2){
		gioca == giocatoreA ? vinc=0 : vinc=1;
		
		cout<<"vince stesso giocatore\n";
		}
	else{
		gioca == giocatoreA ? vinc=0 : vinc=1;
		gioca == giocatoreA ? gioca=giocatoreB : gioca=giocatoreA;
		cout<<"vince altro giocatore\n";
		}	
	cout<<"il vincitore è "<<vinc<<endl;
	calcola_punteggio(vinc, val1, val2);
	cout<<"punteggio giocA = "<<partita.player1.punteggio<<endl;
	cout<<"punteggio giocB = "<<partita.player2.punteggio<<endl;
}


/** Funzione che gestisce la fine di entrambi i turni.
 *  Deve confrontare le due carte sul tavolo di gioco, 
 *  stabilire chi ha vinto,
 *  abilitare il bottone del mazzo, congelando quelli delle carte della mano,
 */
/*void fine_mano(){
	

}*/

void pulisci_tavolo(){
	/* devo pulire il campo digioco
	*/
	
	gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder,"image2")),false);
	gtk_widget_set_visible(GTK_WIDGET(gtk_builder_get_object(builder,"image3")),false);
	}


/** Funzione che cambia il giocatore, e cambia il turno di gioco.
 */
void passa_turno(){

	/* Cambia giocatore:
	 * da fare ogni volta che si cambia il turno.
	 * Dato che lo faccio all'inizio della funzione, quando sono nel caso 2, me lo devo ric.
	 */ 
	gioca == giocatoreA? gioca=giocatoreB : gioca=giocatoreA;

	/* Ha giocato la propria carta solo uno dei due giocatori,
	 * e ora il turno passa all'altro giocatore.
	 */
/* se turn è = primo, allora passa direttamente al secondo, così anche lui gioca la carta, se invece il turno è del secondo, deve agganciare
tutta la fase del conteggio e gestione vittoria. quindi quando è primo, cambia il giocatore, e il turno che passa al secondo, 
mentre seè secondo, controlla il giocatore che ha giocato, quindi la prec sarà dell'altro, guarda chi vince, e setta primo, e il giocatore
che ha vinto.*/
	if(turno == primo){
		turno = secondo;
		}
	
	/* Honno giocato entrambi i giocatori, adesso bisogna: 
	 * gestire chi ha vinto,
	 * liberare le tavolo di gioco,
	 * settare a sensitive il mazzo per poter pescare, 
	 * quindi aggiornare le mani,
	 * e far comparire le carte nuove nelle rispettive mani 
 	 */
	else{
		
		// Congela lo stato del gioco
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta4")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta5")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta6")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta1")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta2")),false);
		gtk_widget_set_sensitive(GTK_WIDGET(gtk_builder_get_object(builder,"carta3")),false);
		
		// Gestisci chi ha vinto
		gestore_vittoria();
		
		turno = primo;		
		//fine_mano();
		
		sleep(1);
		pulisci_tavolo();
		
		// Carica la mano solo alla fine di entrambi i turni
		carica_mano();	
		
		}
	setta_mano();
	


}

